{"version":3,"sources":["typed.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"libs.js","sourcesContent":["// The MIT License (MIT)\r\n\r\n// Typed.js | Copyright (c) 2014 Matt Boldt | www.mattboldt.com\r\n\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n// THE SOFTWARE.\r\n\r\n\r\n\r\n\r\n! function($) {\r\n\r\n    \"use strict\";\r\n\r\n    var Typed = function(el, options) {\r\n\r\n        // chosen element to manipulate text\r\n        this.el = $(el);\r\n\r\n        // options\r\n        this.options = $.extend({}, $.fn.typed.defaults, options);\r\n\r\n        // attribute to type into\r\n        this.isInput = this.el.is('input');\r\n        this.attr = this.options.attr;\r\n\r\n        // show cursor\r\n        this.showCursor = this.isInput ? false : this.options.showCursor;\r\n\r\n        // text content of element\r\n        this.elContent = this.attr ? this.el.attr(this.attr) : this.el.text()\r\n\r\n        // html or plain text\r\n        this.contentType = this.options.contentType;\r\n\r\n        // typing speed\r\n        this.typeSpeed = this.options.typeSpeed;\r\n\r\n        // add a delay before typing starts\r\n        this.startDelay = this.options.startDelay;\r\n\r\n        // backspacing speed\r\n        this.backSpeed = this.options.backSpeed;\r\n\r\n        // amount of time to wait before backspacing\r\n        this.backDelay = this.options.backDelay;\r\n\r\n        // div containing strings\r\n        this.stringsElement = this.options.stringsElement;\r\n\r\n        // input strings of text\r\n        this.strings = this.options.strings;\r\n\r\n        // character number position of current string\r\n        this.strPos = 0;\r\n\r\n        // current array position\r\n        this.arrayPos = 0;\r\n\r\n        // number to stop backspacing on.\r\n        // default 0, can change depending on how many chars\r\n        // you want to remove at the time\r\n        this.stopNum = 0;\r\n\r\n        // Looping logic\r\n        this.loop = this.options.loop;\r\n        this.loopCount = this.options.loopCount;\r\n        this.curLoop = 0;\r\n\r\n        // for stopping\r\n        this.stop = false;\r\n\r\n        // custom cursor\r\n        this.cursorChar = this.options.cursorChar;\r\n\r\n        // shuffle the strings\r\n        this.shuffle = this.options.shuffle;\r\n        // the order of strings\r\n        this.sequence = [];\r\n\r\n        // All systems go!\r\n        this.build();\r\n    };\r\n\r\n    Typed.prototype = {\r\n\r\n        constructor: Typed\r\n\r\n        ,\r\n        init: function() {\r\n            // begin the loop w/ first current string (global self.strings)\r\n            // current string will be passed as an argument each time after this\r\n            var self = this;\r\n            self.timeout = setTimeout(function() {\r\n                for (var i=0;i<self.strings.length;++i) self.sequence[i]=i;\r\n\r\n                // shuffle the array if true\r\n                if(self.shuffle) self.sequence = self.shuffleArray(self.sequence);\r\n\r\n                // Start typing\r\n                self.typewrite(self.strings[self.sequence[self.arrayPos]], self.strPos);\r\n            }, self.startDelay);\r\n        }\r\n\r\n        ,\r\n        build: function() {\r\n            var self = this;\r\n            // Insert cursor\r\n            if (this.showCursor === true) {\r\n                this.cursor = $(\"<span class=\\\"typed-cursor\\\">\" + this.cursorChar + \"</span>\");\r\n                this.el.after(this.cursor);\r\n            }\r\n            if (this.stringsElement) {\r\n                self.strings = [];\r\n                this.stringsElement.hide();\r\n                var strings = this.stringsElement.find('p');\r\n                $.each(strings, function(key, value){\r\n                    self.strings.push($(value).html());\r\n                });\r\n            }\r\n            this.init();\r\n        }\r\n\r\n        // pass current string state to each function, types 1 char per call\r\n        ,\r\n        typewrite: function(curString, curStrPos) {\r\n            // exit when stopped\r\n            if (this.stop === true) {\r\n                return;\r\n            }\r\n\r\n            // varying values for setTimeout during typing\r\n            // can't be global since number changes each time loop is executed\r\n            var humanize = Math.round(Math.random() * (100 - 30)) + this.typeSpeed;\r\n            var self = this;\r\n\r\n            // ------------- optional ------------- //\r\n            // backpaces a certain string faster\r\n            // ------------------------------------ //\r\n            // if (self.arrayPos == 1){\r\n            //  self.backDelay = 50;\r\n            // }\r\n            // else{ self.backDelay = 500; }\r\n\r\n            // contain typing function in a timeout humanize'd delay\r\n            self.timeout = setTimeout(function() {\r\n                // check for an escape character before a pause value\r\n                // format: \\^\\d+ .. eg: ^1000 .. should be able to print the ^ too using ^^\r\n                // single ^ are removed from string\r\n                var charPause = 0;\r\n                var substr = curString.substr(curStrPos);\r\n                if (substr.charAt(0) === '^') {\r\n                    var skip = 1; // skip atleast 1\r\n                    if (/^\\^\\d+/.test(substr)) {\r\n                        substr = /\\d+/.exec(substr)[0];\r\n                        skip += substr.length;\r\n                        charPause = parseInt(substr);\r\n                    }\r\n\r\n                    // strip out the escape character and pause value so they're not printed\r\n                    curString = curString.substring(0, curStrPos) + curString.substring(curStrPos + skip);\r\n                }\r\n\r\n                if (self.contentType === 'html') {\r\n                    // skip over html tags while typing\r\n                    var curChar = curString.substr(curStrPos).charAt(0)\r\n                    if (curChar === '<' || curChar === '&') {\r\n                        var tag = '';\r\n                        var endTag = '';\r\n                        if (curChar === '<') {\r\n                            endTag = '>'\r\n                        } else {\r\n                            endTag = ';'\r\n                        }\r\n                        while (curString.substr(curStrPos).charAt(0) !== endTag) {\r\n                            tag += curString.substr(curStrPos).charAt(0);\r\n                            curStrPos++;\r\n                        }\r\n                        curStrPos++;\r\n                        tag += endTag;\r\n                    }\r\n                }\r\n\r\n                // timeout for any pause after a character\r\n                self.timeout = setTimeout(function() {\r\n                    if (curStrPos === curString.length) {\r\n                        // fires callback function\r\n                        self.options.onStringTyped(self.arrayPos);\r\n\r\n                        // is this the final string\r\n                        if (self.arrayPos === self.strings.length - 1) {\r\n                            // animation that occurs on the last typed string\r\n                            self.options.callback();\r\n\r\n                            self.curLoop++;\r\n\r\n                            // quit if we wont loop back\r\n                            if (self.loop === false || self.curLoop === self.loopCount)\r\n                                return;\r\n                        }\r\n\r\n                        self.timeout = setTimeout(function() {\r\n                            self.backspace(curString, curStrPos);\r\n                        }, self.backDelay);\r\n                    } else {\r\n\r\n                        /* call before functions if applicable */\r\n                        if (curStrPos === 0)\r\n                            self.options.preStringTyped(self.arrayPos);\r\n\r\n                        // start typing each new char into existing string\r\n                        // curString: arg, self.el.html: original text inside element\r\n                        var nextString = curString.substr(0, curStrPos + 1);\r\n                        if (self.attr) {\r\n                            self.el.attr(self.attr, nextString);\r\n                        } else {\r\n                            if (self.isInput) {\r\n                                self.el.val(nextString);\r\n                            } else if (self.contentType === 'html') {\r\n                                self.el.html(nextString);\r\n                            } else {\r\n                                self.el.text(nextString);\r\n                            }\r\n                        }\r\n\r\n                        // add characters one by one\r\n                        curStrPos++;\r\n                        // loop the function\r\n                        self.typewrite(curString, curStrPos);\r\n                    }\r\n                    // end of character pause\r\n                }, charPause);\r\n\r\n                // humanized value for typing\r\n            }, humanize);\r\n\r\n        }\r\n\r\n        ,\r\n        backspace: function(curString, curStrPos) {\r\n            // exit when stopped\r\n            if (this.stop === true) {\r\n                return;\r\n            }\r\n\r\n            // varying values for setTimeout during typing\r\n            // can't be global since number changes each time loop is executed\r\n            var humanize = Math.round(Math.random() * (100 - 30)) + this.backSpeed;\r\n            var self = this;\r\n\r\n            self.timeout = setTimeout(function() {\r\n\r\n                // ----- this part is optional ----- //\r\n                // check string array position\r\n                // on the first string, only delete one word\r\n                // the stopNum actually represents the amount of chars to\r\n                // keep in the current string. In my case it's 14.\r\n                // if (self.arrayPos == 1){\r\n                //  self.stopNum = 14;\r\n                // }\r\n                //every other time, delete the whole typed string\r\n                // else{\r\n                //  self.stopNum = 0;\r\n                // }\r\n\r\n                if (self.contentType === 'html') {\r\n                    // skip over html tags while backspacing\r\n                    if (curString.substr(curStrPos).charAt(0) === '>') {\r\n                        var tag = '';\r\n                        while (curString.substr(curStrPos).charAt(0) !== '<') {\r\n                            tag -= curString.substr(curStrPos).charAt(0);\r\n                            curStrPos--;\r\n                        }\r\n                        curStrPos--;\r\n                        tag += '<';\r\n                    }\r\n                }\r\n\r\n                // ----- continue important stuff ----- //\r\n                // replace text with base text + typed characters\r\n                var nextString = curString.substr(0, curStrPos);\r\n                if (self.attr) {\r\n                    self.el.attr(self.attr, nextString);\r\n                } else {\r\n                    if (self.isInput) {\r\n                        self.el.val(nextString);\r\n                    } else if (self.contentType === 'html') {\r\n                        self.el.html(nextString);\r\n                    } else {\r\n                        self.el.text(nextString);\r\n                    }\r\n                }\r\n\r\n                // if the number (id of character in current string) is\r\n                // less than the stop number, keep going\r\n                if (curStrPos > self.stopNum) {\r\n                    // subtract characters one by one\r\n                    curStrPos--;\r\n                    // loop the function\r\n                    self.backspace(curString, curStrPos);\r\n                }\r\n                // if the stop number has been reached, increase\r\n                // array position to next string\r\n                else if (curStrPos <= self.stopNum) {\r\n                    self.arrayPos++;\r\n\r\n                    if (self.arrayPos === self.strings.length) {\r\n                        self.arrayPos = 0;\r\n\r\n                        // Shuffle sequence again\r\n                        if(self.shuffle) self.sequence = self.shuffleArray(self.sequence);\r\n\r\n                        self.init();\r\n                    } else\r\n                        self.typewrite(self.strings[self.sequence[self.arrayPos]], curStrPos);\r\n                }\r\n\r\n                // humanized value for typing\r\n            }, humanize);\r\n\r\n        }\r\n        /**\r\n         * Shuffles the numbers in the given array.\r\n         * @param {Array} array\r\n         * @returns {Array}\r\n         */\r\n        ,shuffleArray: function(array) {\r\n            var tmp, current, top = array.length;\r\n            if(top) while(--top) {\r\n                current = Math.floor(Math.random() * (top + 1));\r\n                tmp = array[current];\r\n                array[current] = array[top];\r\n                array[top] = tmp;\r\n            }\r\n            return array;\r\n        }\r\n\r\n        // Start & Stop currently not working\r\n\r\n        // , stop: function() {\r\n        //     var self = this;\r\n\r\n        //     self.stop = true;\r\n        //     clearInterval(self.timeout);\r\n        // }\r\n\r\n        // , start: function() {\r\n        //     var self = this;\r\n        //     if(self.stop === false)\r\n        //        return;\r\n\r\n        //     this.stop = false;\r\n        //     this.init();\r\n        // }\r\n\r\n        // Reset and rebuild the element\r\n        ,\r\n        reset: function() {\r\n            var self = this;\r\n            clearInterval(self.timeout);\r\n            var id = this.el.attr('id');\r\n            this.el.after('<span id=\"' + id + '\"/>')\r\n            this.el.remove();\r\n            if (typeof this.cursor !== 'undefined') {\r\n                this.cursor.remove();\r\n            }\r\n            // Send the callback\r\n            self.options.resetCallback();\r\n        }\r\n\r\n    };\r\n\r\n    $.fn.typed = function(option) {\r\n        return this.each(function() {\r\n            var $this = $(this),\r\n                data = $this.data('typed'),\r\n                options = typeof option == 'object' && option;\r\n            if (!data) $this.data('typed', (data = new Typed(this, options)));\r\n            if (typeof option == 'string') data[option]();\r\n        });\r\n    };\r\n\r\n    $.fn.typed.defaults = {\r\n        strings: [\"These are the default values...\", \"You know what you should do?\", \"Use your own!\", \"Have a great day!\"],\r\n        stringsElement: null,\r\n        // typing speed\r\n        typeSpeed: 0,\r\n        // time before typing starts\r\n        startDelay: 0,\r\n        // backspacing speed\r\n        backSpeed: 0,\r\n        // shuffle the strings\r\n        shuffle: false,\r\n        // time before backspacing\r\n        backDelay: 500,\r\n        // loop\r\n        loop: false,\r\n        // false = infinite\r\n        loopCount: false,\r\n        // show cursor\r\n        showCursor: true,\r\n        // character for cursor\r\n        cursorChar: \"|\",\r\n        // attribute to type (null == text)\r\n        attr: null,\r\n        // either html or text\r\n        contentType: 'html',\r\n        // call when done callback function\r\n        callback: function() {},\r\n        // starting callback function before each string\r\n        preStringTyped: function() {},\r\n        //callback for every typed string\r\n        onStringTyped: function() {},\r\n        // callback for reset\r\n        resetCallback: function() {}\r\n    };\r\n\r\n\r\n}(window.jQuery);\r\n"],"sourceRoot":"/source/"}